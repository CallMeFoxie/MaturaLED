/*
 * iface.asm
 *
 *  Created: 8.3.2012 14:52:12
 *   Author: Ondra
 */ 
.def GAME_IFACE_CR = R25
.equ GAME_IFACE_TIMER0_BIT = 0
.equ GAME_IFACE_TIMER1_BIT = 1
.equ GAME_IFACE_TIMER2_BIT = 2
.equ GAME_IFACE_VEN = 3

.equ GAME_MEM_START = 0x1100 ; start at xmem offset
.equ GAME_MEM_SIZE = 0x8000 ; 32kB should be enough

.dseg
.org 0x9100
	GAME_OFFSET_TIMER0: .byte 2
	GAME_OFFSET_TIMER1: .byte 2
	GAME_OFFSET_TIMER2: .byte 2

	/* R5 = CR:
	 +---+---+---+---+---+----+----+----+
	 | 0 | 0 | 0 | 0 | 0 | T2 | T1 | T0 |
	 +---+---+---+---+---+----+----+----+
		T = enable timer calls
	*/
.cseg

GAME_IFACE_INIT:
	PUSH	R16
	IN		R16, SREG
	PUSH	R16
	PUSH	YL
	PUSH	YH
	; clear out GAME_OFFSET_TIMERs and reset control register
	LDI		R16, 0x00
	
	LDI		YL, LOW(GAME_OFFSET_TIMER0)
	LDI		YH, HIGH(GAME_OFFSET_TIMER0)
	ST		Y+, R16
	ST		Y, R16

	LDI		YL, LOW(GAME_OFFSET_TIMER1)
	LDI		YH, HIGH(GAME_OFFSET_TIMER1)
	ST		Y+, R16
	ST		Y, R16

	LDI		YL, LOW(GAME_OFFSET_TIMER2)
	LDI		YH, HIGH(GAME_OFFSET_TIMER2)
	ST		Y+, R16
	ST		Y, R16
	
	;CLR		R5

.ifdef GAME_INIT
	;RCALL	GAME_INIT
	; enable all interrupts
	IN		R16, TIMSK
	ORI		R16, (1<<OCIE1A)|(1<<OCIE1B)|(1<<TOIE1)
	;OUT		TIMSK, R16
.endif
	POP		YH
	POP		YL
	POP		R16
	OUT		SREG, R16
	POP		R16
	RET

.macro GAME_IFACE_PUSHES
	PUSH	R16
	IN		R16, SREG
	PUSH	R16
	PUSH	ZL
	PUSH	ZH
	PUSH	R17
.endmacro

.macro GAME_IFACE_POPS	
	POP		R17
	POP		ZH
	POP		ZL
	POP		R16
	OUT		SREG, R16
	POP		R16
.endmacro

GAME_IFACE_TIMER0:
.ifdef GAME_TIMER0
.message "Adding Game Timer0"
	SEI
	/*PUSH	GAME_IFACE_CR
	ANDI	GAME_IFACE_CR, (1<<GAME_IFACE_TIMER0_BIT)
	BREQ	GAME_IFACE_TIMER0_DONE
	GAME_IFACE_PUSHES
	LDI		ZL, LOW(GAME_OFFSET_TIMER0)
	LDI		ZH, HIGH(GAME_OFFSET_TIMER0)
	LD		R16, Z+
	LD		R17, Z
	MOV		ZL, R16
	MOV		ZH, R17
	ICALL
GAME_IFACE_TIMER0_DONE:
	GAME_IFACE_POPS
	POP	GAME_IFACE_CR*/
		CALL	GAME_TIMER0
.endif
	RETI

GAME_IFACE_TIMER1:
.ifdef GAME_TIMER1
.message "Adding Game Timer1"
	SEI
	/*PUSH	GAME_IFACE_CR
	ANDI	GAME_IFACE_CR, (1<<GAME_IFACE_TIMER1_BIT)
	BREQ	GAME_IFACE_TIMER1_DONE
	GAME_IFACE_PUSHES
	LDI		ZL, LOW(GAME_OFFSET_TIMER1)
	LDI		ZH, HIGH(GAME_OFFSET_TIMER1)
	LD		R16, Z+
	LD		R17, Z
	MOV		ZL, R16
	MOV		ZH, R17
	ICALL
GAME_IFACE_TIMER1_DONE:
	GAME_IFACE_POPS
	POP	GAME_IFACE_CR*/
	CALL	GAME_TIMER1
.endif
	RETI

GAME_IFACE_TIMER2:
.ifdef GAME_TIMER2
.message "Adding Game Timer2"
	SEI
	/*PUSH	GAME_IFACE_CR
	ANDI	GAME_IFACE_CR, (1<<GAME_IFACE_TIMER2_BIT)
	BREQ	GAME_IFACE_TIMER2_DONE
	GAME_IFACE_PUSHES
	LDI		ZL, LOW(GAME_OFFSET_TIMER2)
	LDI		ZH, HIGH(GAME_OFFSET_TIMER2)
	LD		R16, Z+
	LD		R17, Z
	MOV		ZL, R16
	MOV		ZH, R17
	ICALL
GAME_IFACE_TIMER2_DONE:
	GAME_IFACE_POPS
	POP	GAME_IFACE_CR*/
		CALL	GAME_TIMER2
.endif
	RETI

/* GAME_IFACE_GET_CONTROLLERS: returns statuses of both controllers (R16, R17) */
GAME_IFACE_GET_CONTROLLERS:
	CLI ; disable interrupts so we don't miss anything
	SBI		PortB, PB6 ; LOAD
	NOP
	CBI		PortB, PB6
	LDI		R16, 0x00
	SBI		PortB, PB5 ; controller 2
	RCALL	SPI_Send
	IN		R17, SPDR
	CBI		PortB, PB5
	SBI		PortB, PB4 ; controller 1
	RCALL	SPI_Send
	IN		R16, SPDR
	SEI ; enable interrupts again and let it run the missed one.
	RET

/* GAME_IFACE_MEM_RESET: Resets current buffer and fills it with 00s */
GAME_IFACE_MEM_RESET:
	PUSH	YL
	PUSH	YH
	PUSH	R16
	PUSH	ZL
	PUSH	ZH

	LDI		YL, LOW(BUFFER0) ; TODO: FIX
	LDI		YH, HIGH(BUFFER0)
	TST		R3
	BREQ	GAME_IFACE_MEM_RESET_CONTINUE ; buffer 0
	ADDI16	0x00, 0x20, YL, YH
	MOVW	Y, Z
GAME_IFACE_MEM_RESET_CONTINUE:
	LDI		R16, 0x00
	LDI		ZL, 0x00
	LDI		ZH, 0x00
	; Z = counter...
GAME_IFACE_MEM_LOOP:
	ST		Y+, R16
	ADIW	Z, 1
	CPI16	ZL, ZH, 0x2000 ; 0x2000 iterations
	BREQ	GAME_IFACE_MEM_RESET_DONE
	RJMP	GAME_IFACE_MEM_LOOP
GAME_IFACE_MEM_RESET_DONE:
	POP		ZH
	POP		ZL
	POP		R16
	POP		YH
	POP		YL
	RET